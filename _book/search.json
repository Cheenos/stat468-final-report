[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STAT 468 Final Project Report",
    "section": "",
    "text": "Abstract\nPoker may be a game of incomplete information, but the modern table is overflowing with data, stack depths, bet sizes, board textures, and the subtle gaps between pot odds and real equity that separate a solid value bet from an expensive bluff. My goal was to capture that information while the chips are still moving, enrich it with fast analytics, and surface insights quickly enough to influence live play.\nTo do this I built an R shiny \"Poker EV tool\". This app replaces the scratch pad notetaking with an end-to-end pipeline that follows the classic data-science staircase.\nData → Tidy → Transform → Model → Visualize → Communicate\nThe result is a tool that turns raw hand histories into actionable coaching notes in seconds, setting the stage for deeper Monte-Carlo equity engines, live dashboards, and what-if simulators outlined later in this report.\nThe Poker Data Recorder squarely tackles the talent-management functions that matter most at the table. It turns every action into equity versus odds metrics, an HMM-based bluff rate, and a single Optimality score, giving you rigorous player evaluation and prospect assessment in minutes rather than hours. Because the summaries call out who is leaking EV and how, the app also serves as a player-development aid; coaches can hand a struggling grinder a bullet-point list of specific leaks to plug. The live EV trend and aggression bubble plot feed directly into on-field strategy and real-time decision making: you instantly see whether to isolate, avoid, or lean on a given opponent. At the group level these same metrics help with light personnel decisions such as who to stake, who to bench, or how to seat friends in a home game, nudging you toward an optimized roster value. Functions that hinge on external bankroll contracts, such as full trade analysis, roster construction, asset valuation, and formal player acquisition strategy, sit outside the app's current scope, but the rich performance data it produces would be the natural input for those higher-level front-office tools.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Abstract</span>"
    ]
  },
  {
    "objectID": "index.html#httpscheenos.shinyapps.iopoker-metrics",
    "href": "index.html#httpscheenos.shinyapps.iopoker-metrics",
    "title": "STAT 468 Final Project Report",
    "section": "https://cheenos.shinyapps.io/poker-metrics/",
    "text": "https://cheenos.shinyapps.io/poker-metrics/",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Abstract</span>"
    ]
  },
  {
    "objectID": "01-data.html",
    "href": "01-data.html",
    "title": "Chapter 1: Data",
    "section": "",
    "text": "Data Collection and Generation\nThe project runs on two deliberately different data sets so the pipeline would face both idealized input and real-world chaos.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Chapter 1: Data</span>"
    ]
  },
  {
    "objectID": "02-tidy.html",
    "href": "02-tidy.html",
    "title": "Chapter 2: Tidy",
    "section": "",
    "text": "Tidy\nThe tidying layer is almost entirely code-driven and lives inside 2 helpers within the file.\n{: #tbl:helpers tbl-cap=“Table 2.1: Overview of helper functions in the pipeline.”}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 2: Tidy</span>"
    ]
  },
  {
    "objectID": "03-transform.html",
    "href": "03-transform.html",
    "title": "Chapter 3: Transform",
    "section": "",
    "text": "Transform\nAfter the tidy step every action sits in a long data frame with the raw columns HandNumber, Dealer, Player, Hole Card 1 and 2, Action, BetAmount, StackBefore, Street. The bulk of the transforming uses the function recalc_analytics which enriches the table with quantitative features that power every later model and plot.\n\n\nCode\n## Load packages\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(tibble)\nlibrary(knitr)\n\n## Example raw data\nbefore_df &lt;- tibble::tribble(\n  ~HandNumber, ~Street,                        ~Action, ~BetAmount, ~StackBefore, ~Hole1, ~Hole2,\n  1001,        \"Pre-flop\",                     \"bet\",          6,          100,     \"Ah\",  \"Kd\",\n  1001,        \"Pre-flop\",                     \"call\",         6,          120,     \"Qs\",  \"Qh\",\n  1001,        \"Flop: [Ah Kd 7c]\",             \"raise\",       18,          114,     \"Ah\",  \"Kd\",\n  1001,        \"Turn: [Ah Kd 7c] 3s\",          \"call\",        18,          102,     \"Qs\",  \"Qh\",\n  1001,        \"River: [Ah Kd 7c 3s] Qh\",      \"bet\",         30,           84,     \"Ah\",  \"Kd\",\n  1002,        \"Pre-flop\",                     \"bet\",          4,           90,     \"9c\",  \"9d\",\n  1002,        \"Flop: [2c 7d 9s]\",             \"call\",         4,           76,     \"Jc\",  \"Tc\",\n  1002,        \"Turn: [2c 7d 9s] As\",          \"raise\",       12,           72,     \"Jc\",  \"Tc\",\n  1002,        \"River: [2c 7d 9s As] Qd\",      \"call\",        12,           60,     \"9c\",  \"9d\"\n)\n\n## Supporting equity function\napprox_equity &lt;- function(hole, street) {\n  if (is.na(hole)) return(NA_real_)\n  ranks &lt;- unlist(strsplit(gsub(\"[^A2-9TJQK ]\",\"\", hole), \" \"))\n  score &lt;- function(r) switch(substr(r,1,1),\n    \"A\"=14,\"K\"=13,\"Q\"=12,\"J\"=11,\"T\"=10,\"9\"=9,\"8\"=8,\"7\"=7,\"6\"=6,\"5\"=5,\"4\"=4,\"3\"=3,\"2\"=2, 5)\n  base &lt;- (sum(vapply(ranks, score, 1)) - 4) / 24\n  bump &lt;- if (street == \"Pre-flop\") 0 else if (startsWith(street,\"Flop\")) 0.05\n          else if (startsWith(street,\"Turn\")) 0.07 else if (startsWith(street,\"River\")) 0.09 else 0\n  pmin(pmax(base + bump, 0.05), 0.95)\n}\n\n## Main function\nrecalc_analytics &lt;- function(df) {\n  df %&gt;%\n    mutate(\n      HoleCards = paste(Hole1, Hole2),\n      StreetOrder = case_when(\n        Street == \"Pre-flop\"        ~ 1L,\n        str_starts(Street, \"Flop\")  ~ 2L,\n        str_starts(Street, \"Turn\")  ~ 3L,\n        str_starts(Street, \"River\") ~ 4L,\n        TRUE                        ~ 5L\n      )\n    ) %&gt;%\n    group_by(HandNumber) %&gt;%\n    arrange(HandNumber, StreetOrder, .by_group = TRUE) %&gt;%\n    mutate(\n      Contribution = pmin(BetAmount, StackBefore),\n      Pot          = cumsum(Contribution),\n      PotBefore    = lag(Pot, default = 0),\n      Equity       = mapply(approx_equity, HoleCards, Street),\n\n      CostToCall   = if_else(Action == \"call\", BetAmount, NA_real_),\n      PotOdds      = CostToCall / (PotBefore + CostToCall),\n\n      PrevBet      = lag(if_else(Action %in% c(\"bet\",\"raise\",\"call\"), BetAmount, 0), default = 0),\n      CostOfWager  = case_when(\n        Action == \"call\"  ~ BetAmount,\n        Action == \"bet\"   ~ BetAmount,\n        Action == \"raise\" ~ BetAmount - PrevBet,\n        TRUE              ~ NA_real_\n      ),\n      WagerOdds    = CostOfWager / (PotBefore + CostOfWager),\n\n      BluffGap     = WagerOdds - Equity,\n      RelSize      = if_else(PotBefore &gt; 0, BetAmount / PotBefore, NA_real_),\n\n      EV_call  = if_else(Action == \"call\",\n                         Equity * (PotBefore + CostToCall) - CostToCall, NA_real_),\n      EV_bet   = if_else(Action == \"bet\",\n                         Equity * (PotBefore + BetAmount) - (1 - Equity) * BetAmount, NA_real_),\n      EV_raise = if_else(Action == \"raise\",\n                         Equity * (PotBefore + CostOfWager) - (1 - Equity) * CostOfWager, NA_real_)\n    ) %&gt;%\n    ungroup() %&gt;%\n    select(-Contribution, -Pot, -CostToCall, -PrevBet, -CostOfWager)\n}\n\n## Output\nkable(before_df, caption = \"Before: Raw hand actions\")\n\n\n\nBefore: Raw hand actions\n\n\n\n\n\n\n\n\n\n\n\nHandNumber\nStreet\nAction\nBetAmount\nStackBefore\nHole1\nHole2\n\n\n\n\n1001\nPre-flop\nbet\n6\n100\nAh\nKd\n\n\n1001\nPre-flop\ncall\n6\n120\nQs\nQh\n\n\n1001\nFlop: [Ah Kd 7c]\nraise\n18\n114\nAh\nKd\n\n\n1001\nTurn: [Ah Kd 7c] 3s\ncall\n18\n102\nQs\nQh\n\n\n1001\nRiver: [Ah Kd 7c 3s] Qh\nbet\n30\n84\nAh\nKd\n\n\n1002\nPre-flop\nbet\n4\n90\n9c\n9d\n\n\n1002\nFlop: [2c 7d 9s]\ncall\n4\n76\nJc\nTc\n\n\n1002\nTurn: [2c 7d 9s] As\nraise\n12\n72\nJc\nTc\n\n\n1002\nRiver: [2c 7d 9s As] Qd\ncall\n12\n60\n9c\n9d\n\n\n\n\n\nCode\nafter_df &lt;- recalc_analytics(before_df)\nkable(after_df, caption = \"After: Derived analytics\")\n\n\n\nAfter: Derived analytics\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHandNumber\nStreet\nAction\nBetAmount\nStackBefore\nHole1\nHole2\nHoleCards\nStreetOrder\nPotBefore\nEquity\nPotOdds\nWagerOdds\nBluffGap\nRelSize\nEV_call\nEV_bet\nEV_raise\n\n\n\n\n1001\nPre-flop\nbet\n6\n100\nAh\nKd\nAh Kd\n1\n0\n0.9500000\nNA\n1.0000000\n0.0500000\nNA\nNA\n5.4000000\nNA\n\n\n1001\nPre-flop\ncall\n6\n120\nQs\nQh\nQs Qh\n1\n6\n0.8333333\n0.500\n0.5000000\n-0.3333333\n1.000\n4.000000\nNA\nNA\n\n\n1001\nFlop: [Ah Kd 7c]\nraise\n18\n114\nAh\nKd\nAh Kd\n2\n12\n0.9500000\nNA\n0.5000000\n-0.4500000\n1.500\nNA\nNA\n22.20\n\n\n1001\nTurn: [Ah Kd 7c] 3s\ncall\n18\n102\nQs\nQh\nQs Qh\n3\n30\n0.9033333\n0.375\n0.3750000\n-0.5283333\n0.600\n25.360000\nNA\nNA\n\n\n1001\nRiver: [Ah Kd 7c 3s] Qh\nbet\n30\n84\nAh\nKd\nAh Kd\n4\n48\n0.9500000\nNA\n0.3846154\n-0.5653846\n0.625\nNA\n72.6000000\nNA\n\n\n1002\nPre-flop\nbet\n4\n90\n9c\n9d\n9c 9d\n1\n0\n0.5833333\nNA\n1.0000000\n0.4166667\nNA\nNA\n0.6666667\nNA\n\n\n1002\nFlop: [2c 7d 9s]\ncall\n4\n76\nJc\nTc\nJc Tc\n2\n4\n0.7583333\n0.500\n0.5000000\n-0.2583333\n1.000\n2.066667\nNA\nNA\n\n\n1002\nTurn: [2c 7d 9s] As\nraise\n12\n72\nJc\nTc\nJc Tc\n3\n8\n0.7783333\nNA\n0.5000000\n-0.2783333\n1.500\nNA\nNA\n10.68\n\n\n1002\nRiver: [2c 7d 9s As] Qd\ncall\n12\n60\n9c\n9d\n9c 9d\n4\n20\n0.6733333\n0.375\n0.3750000\n-0.2983333\n0.600\n9.546667\nNA\nNA\n\n\n\n\n\n\n\n\n\n\n\n\n\nNew column\nFormula (chips)\nIntuition\n\n\n\n\nContribution\npmin(BetAmount, StackBefore)\nThe most a player can actually put in this street.\n\n\nPot\ncumsum(Contribution)(within each hand)\nRunning pot size after the current action.\n\n\nPotBefore\nlag(Pot, default = 0)\nPot size just before a player acts.\n\n\nCostToCall\nif_else(Action == \"call\", BetAmount, NA_real_)\nAmount needed to continue when facing a bet.\n\n\nPotOdds\nCostToCall / (PotBefore + CostToCall)\nPrice being laid for a call.\n\n\nPrevBet\nlag(if_else(Action %in% c(\"bet\",\"raise\",\"call\"), BetAmount, 0), default = 0)\nUsed to isolate the incremental part of a raise.\n\n\nCostOfWager\ncase_when( Action == \"call\"  ~ BetAmount, Action == \"bet\"   ~ BetAmount, Action == \"raise\" ~ BetAmount - PrevBet, TRUE              ~ NA_real_)\nTrue amount risked (bet, call, or raise – PrevBet).\n\n\nWagerOdds\nCostOfWager / (PotBefore + CostOfWager)\nPrice a bettor is offering the table.\n\n\nBluffGap\nWagerOdds - Equity\nMargin between price offered and hand strength.\n\n\nRelSize\nif_else(PotBefore &gt; 0, BetAmount / PotBefore, NA_real_)\nBet size expressed as a fraction of the pot.\n\n\nEV_call\nif_else(Action == \"call\", Equity * (PotBefore + CostToCall) - CostToCall, NA_real_)\nClassic expectation of a call.\n\n\nEV_bet\nif_else(Action == \"bet\", Equity * (PotBefore + BetAmount) - (1 - Equity) * BetAmount, NA_real_)\nExpected value of an outright bet.\n\n\nEV_raise\nif_else(Action == \"raise\", Equity * (PotBefore + CostOfWager) - (1 - Equity) * CostOfWager, NA_real_)\nExpected value of a raise.\n\n\n\nTable 3.1: Derived analytics columns with formulas and intuition\n\nEquity Proxy\nTo circumvent the time and processing power used to generate exact Monte-Carlo equity, we use approx_equity(hole, street) which looks up a fast pre-flop table (Chen formula) or a turn/river. This keeps latency &lt; 30 ms per action so the live recorder stays responsive.\n\n\nExpected Value columns\nThree mutually exclusive columns (EV_call, EV_bet, EV_raise) are populated so that the EV-trend plot can call coalesce() and get the correct value regardless of action type. A dashed horizontal zero line in that plot lets players see at a glance which decisions gained or bled chips.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 3: Transform</span>"
    ]
  },
  {
    "objectID": "04-modelling.html",
    "href": "04-modelling.html",
    "title": "Chapter 4: Modelling",
    "section": "",
    "text": "Modelling\nOur modelling layer has two goals: (i) assign every bet or raise a live probability that the actor is bluff‑heavy, and (ii) roll per‑player statistics into a single “Optimality” KPI that balances value betting, smart aggression, and controlled bluffing. We lean on the poker‑AI literature for both feature choices and mathematical footing: Billings’ work on computer‑poker evaluation (Billings & al., 2006), Chen & Ankenman’s equity‑versus‑price calculus (Chen & Ankenman, 2006), Sire’s tournament‑flow statistics (Sire, 2007), Teófilo’s abstraction heuristics (Kuznetsov, 2024), Kang & Shelton’s HMM opponent‑modelling insights (Kuznetsov, 2024), and modern variance‑reduction techniques (AIVAT (Burch et al., 2020)). The subsections below detail our implementation, show the equations, and justify defaults with citations.\nWe need two layers of insight:\n\nA Hidden Markov Model (HMM) that tags each bet or raise with a live bluff probability, and\n\nAn Optimality score that aggregates edge, volume, and discipline into one number.\n\nThese choices echo classic computer‑poker work (Billings; Chen & Ankenman) (Billings & al., 2006; Chen & Ankenman, 2006) and later real‑time opponent‑modelling papers (Kang & Shelton) (Kuznetsov, 2024).\n\nHidden Markov Model: “Is this bet a bluff?”\nPoker hands arrive as an unlabelled time series of actions. We do not directly observe whether a wager is value or bluff, yet that latent intent drives strategy. A Hidden Markov Model fits this setting.\nFrom the transform stage we carry four statistics:\n\n\n\nSymbol\nMeaning\n\n\n\n\n\\(E\\)\nequity proxy\n\n\n\\(O\\)\nprice offered (WagerOdds)\n\n\n\\(G = O - E\\)\nBluff Gap\n\n\n\\(R\\)\nrelative bet size\n\n\n\n{: #tbl:transform-stats tbl-cap=“Table 2.1: Four transform‑stage statistics.”}\n\n\nTwo‑state Gaussian HMM\nWe model hidden states V (Value) and B (Bluff). Each emits \\((G, R)\\) with independent normals; parameters and the transition matrix are learned via Expectation–Maximization. This is the simplest model that captures the qualitative switches noted in real‑time opponent studies (Kuznetsov, 2024). Early experiments with 3–4 states overfit.\n\n\nGaussian emissions\nBluffGap and RelativeBetSize are roughly bell‑shaped after truncating tails. A diagonal covariance keeps the parameter count low and stabilizes EM.\nPosterior coding gives \\[\n\\label{eq:pbluff}\np_{\\mathrm{bluff}} \\;=\\; P\\!\\bigl(S_t = B \\mid G_t, R_t\\bigr).\n\\]\nIf a player has fewer than three aggressive actions, we skip the model and leave the bluff field NA to avoid small‑sample noise.\nWe also considered logistic regression; the absence of labelled bluffs makes it impractical here.\n\n\nOptimality score: from micro‑metrics to one KPI\nThe Optimality index answers: Who is actually playing well once volume and bluff discipline are considered? Starting from Chen & Ankenman’s edge idea—take a call/bet/raise only when \\[\n\\overline{E} - \\overline{O} &gt; 0,\n\\] with \\[\n\\overline{E} = \\text{mean equity}, \\qquad \\overline{O} = \\text{mean price paid},\n\\] we add two modifiers:\n\n\n\n\n\n\n\n\nModifier\nRationale\nScaling\n\n\n\n\n\\(\\nu = \\dfrac{n_{\\text{actions}}}{n_{\\text{hands}}}\\)\nProfitable spots taken more often grow the bankroll faster; normalising by hands avoids favouring marathon sessions.\n\\(0 \\le \\nu \\le 1\\)\n\n\n\\(B\\) (bluff bonus/penalty)\nA controlled share of +EV bluffs raises win rate; the same share with negative edge accelerates losses (Billings et al., 2006).\n\\(B=\\begin{cases}1+\\mathrm{BluffRate}, & \\text{if Edge}&gt;0\\\\[2pt] 1-\\mathrm{BluffRate}, & \\text{if Edge}&lt;0\\end{cases}\\)\n\n\n\n{: #tbl:opt-modifiers tbl-cap=“Table 4.1: Modifiers and scaling for the Optimality index.”}\nThe final score is \\[\n\\label{eq:opt}\n\\mathrm{Opt} \\;=\\; (\\overline{E} - \\overline{O}) \\times \\nu \\times B.\n\\]\n\n\nVariance notes: “Making live EV readings believable”\nPer‑action equity is notoriously noisy—river cards alone can swing expectation by a full pot. Following variance‑reduction ideas (e.g., AIVAT) (Burch et al., 2020), we focus on EV rather than raw equity and, per street, use conditional expectations given the exposed board. Lower variance stabilizes both the HMM training and the Optimality ranking, making small‑hand samples less prone to lucky heat‑runs.\n\n\nNext steps in modelling\n\nReplace approx_equity() with Monte‑Carlo equity simulation to remove lookup bias and handle arbitrary textures.\n\nTune the volume and bluff multipliers via grid search or Bayesian optimisation against a hold‑out of live profit traces.\n\nAdd a Hero‑only bluff metric that conditions on Hero’s hole cards and opponent ranges (no opponent hole‑card peeks).\n\n\n\n\nModelling\nOur modelling layer has two goals: (i) assign every bet or raise a live probability that the actor is bluff‑heavy, and (ii) roll per‑player statistics into a single “Optimality” KPI that balances value betting, smart aggression, and controlled bluffing. We lean on the poker‑AI literature for both feature choices and mathematical footing: Billings’ work on computer‑poker evaluation (Billings & al., 2006), Chen & Ankenman’s equity‑versus‑price calculus (Chen & Ankenman, 2006), Sire’s tournament‑flow statistics (Sire, 2007), Teófilo’s abstraction heuristics (Kuznetsov, 2024), Kang & Shelton’s HMM opponent‑modelling insights (Kuznetsov, 2024), and modern variance‑reduction techniques (AIVAT (Burch et al., 2020)). The subsections below detail our implementation, show the equations, and justify defaults with citations.\nWe need two layers of insight:\n\nA Hidden Markov Model (HMM) that tags each bet or raise with a live bluff probability, and\n\nAn Optimality score that aggregates edge, volume, and discipline into one number.\n\nThese choices echo classic computer‑poker work (Billings; Chen & Ankenman) (Billings & al., 2006; Chen & Ankenman, 2006) and later real‑time opponent‑modelling papers (Kang & Shelton) (Kuznetsov, 2024).\n\nHidden Markov Model: “Is this bet a bluff?”\nPoker hands arrive as an unlabelled time series of actions. We do not directly observe whether a wager is value or bluff, yet that latent intent drives strategy. A Hidden Markov Model fits this setting.\nFrom the transform stage we carry four statistics:\n\n\n\nSymbol\nMeaning\n\n\n\n\n\\(E\\)\nequity proxy\n\n\n\\(O\\)\nprice offered (WagerOdds)\n\n\n\\(G = O - E\\)\nBluff Gap\n\n\n\\(R\\)\nrelative bet size\n\n\n\n{: #tbl:transform-stats tbl-cap=“Table 2.1: Four transform‑stage statistics.”}\n\n\nTwo‑state Gaussian HMM\nWe model hidden states V (Value) and B (Bluff). Each emits \\((G, R)\\) with independent normals; parameters and the transition matrix are learned via Expectation–Maximization. This is the simplest model that captures the qualitative switches noted in real‑time opponent studies (Kuznetsov, 2024). Early experiments with 3–4 states overfit.\n\n\nGaussian emissions\nBluffGap and RelativeBetSize are roughly bell‑shaped after truncating tails. A diagonal covariance keeps the parameter count low and stabilizes EM.\nPosterior coding gives \\[\n\\label{eq:pbluff}\np_{\\mathrm{bluff}} \\;=\\; P\\!\\bigl(S_t = B \\mid G_t, R_t\\bigr).\n\\]\nIf a player has fewer than three aggressive actions, we skip the model and leave the bluff field NA to avoid small‑sample noise.\nWe also considered logistic regression; the absence of labelled bluffs makes it impractical here.\n\n\nOptimality score: from micro‑metrics to one KPI\nThe Optimality index answers: Who is actually playing well once volume and bluff discipline are considered? Starting from Chen & Ankenman’s edge idea—take a call/bet/raise only when \\[\n\\overline{E} - \\overline{O} &gt; 0,\n\\] with \\[\n\\overline{E} = \\text{mean equity}, \\qquad \\overline{O} = \\text{mean price paid},\n\\] we add two modifiers:\n\n\n\n\n\n\n\n\nModifier\nRationale\nScaling\n\n\n\n\n\\(\\nu = \\dfrac{n_{\\text{actions}}}{n_{\\text{hands}}}\\)\nProfitable spots taken more often grow the bankroll faster; normalising by hands avoids favouring marathon sessions.\n\\(0 \\le \\nu \\le 1\\)\n\n\n\\(B\\) (bluff bonus/penalty)\nA controlled share of +EV bluffs raises win rate; the same share with negative edge accelerates losses (Billings et al., 2006).\n\\(B=\\begin{cases}1+\\mathrm{BluffRate}, & \\text{if Edge}&gt;0\\\\[2pt] 1-\\mathrm{BluffRate}, & \\text{if Edge}&lt;0\\end{cases}\\)\n\n\n\n{: #tbl:opt-modifiers tbl-cap=“Table 4.1: Modifiers and scaling for the Optimality index.”}\nThe final score is \\[\n\\label{eq:opt}\n\\mathrm{Opt} \\;=\\; (\\overline{E} - \\overline{O}) \\times \\nu \\times B.\n\\]\n\n\nVariance notes: “Making live EV readings believable”\nPer‑action equity is notoriously noisy—river cards alone can swing expectation by a full pot. Following variance‑reduction ideas (e.g., AIVAT) (Burch et al., 2020), we focus on EV rather than raw equity and, per street, use conditional expectations given the exposed board. Lower variance stabilizes both the HMM training and the Optimality ranking, making small‑hand samples less prone to lucky heat‑runs.\n\n\nNext steps in modelling\n\nReplace approx_equity() with Monte‑Carlo equity simulation to remove lookup bias and handle arbitrary textures.\n\nTune the volume and bluff multipliers via grid search or Bayesian optimisation against a hold‑out of live profit traces.\n\nAdd a Hero‑only bluff metric that conditions on Hero’s hole cards and opponent ranges (no opponent hole‑card peeks).\n\n\n\n\n\nBillings, D., & al., et. (2006). Algorithms and assessment in computer poker. AAAI Spring Symposium.\n\n\nBurch, P. et al. (2020). AIVAT: An action‐informed variance reduction method for poker. Transactions on Games.\n\n\nChen, B., & Ankenman, J. (2006). The mathematics of poker. ConJelCo LLC.\n\n\nKuznetsov. (2024). Hidden markov models for opponent modelling in poker. Proc. Of Another Conf.\n\n\nSire, C. (2007). Universal statistical properties of poker tournaments. Journal of Statistical Mechanics.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 4: Modelling</span>"
    ]
  },
  {
    "objectID": "05-visualize_and_communicate.html",
    "href": "05-visualize_and_communicate.html",
    "title": "6  Chapter 5: Visualize and Communicate",
    "section": "",
    "text": "7 Visualizing and Communication {#V&C}\nOnce every action is enriched with equity, EV, bluff-probability, and stack context, we use 3 key plots to surface patterns at a glance. All code lives in the server file’s renderplot() calls.\n\n7.0.1 Stack and Plot Volume Area Chart\nThis chart shows how each player’s stack evolves hand-by-hand alongside the total pot size.\n\n\nCode\n# ===============================\n# Libraries\n# ===============================\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(readxl)\nlibrary(ggplot2)\n\n# ===============================\n# Load Data\n# ===============================\ndata_path &lt;- \"C:/Users/eddy2/OneDrive/Documents/Stat 468/Final Project/PokerDta/poker_log-Hand1.xlsx\" \nraw_df &lt;- read_excel(data_path)\n\n# ===============================\n# Helper: Equity Approximation\n# ===============================\napprox_equity &lt;- function(hole, street) {\n  if (is.na(hole)) return(NA_real_)\n  ranks &lt;- unlist(strsplit(gsub(\"[^A2-9TJQK ]\", \"\", hole), \" \"))\n  score &lt;- function(r) switch(substr(r,1,1),\n                              \"A\"=14, \"K\"=13, \"Q\"=12, \"J\"=11, \"T\"=10,\n                              \"9\"=9, \"8\"=8, \"7\"=7, \"6\"=6, \"5\"=5,\n                              \"4\"=4, \"3\"=3, \"2\"=2, 5)\n  base &lt;- (sum(vapply(ranks, score, 1)) - 4) / 24\n  bump &lt;- if (street == \"Pre-flop\") 0\n          else if (startsWith(street,\"Flop\")) 0.05\n          else if (startsWith(street,\"Turn\")) 0.07\n          else if (startsWith(street,\"River\")) 0.09\n          else 0\n  pmin(pmax(base + bump, 0.05), 0.95)\n}\n\n# ===============================\n# Analytics Calculation Function\n# ===============================\nrecalc_analytics &lt;- function(df) {\n  df %&gt;%\n    mutate(\n      HoleCards = paste(Hole1, Hole2),\n      StreetOrder = case_when(\n        Street == \"Pre-flop\"        ~ 1L,\n        grepl(\"^Flop\", Street)      ~ 2L,\n        grepl(\"^Turn\", Street)      ~ 3L,\n        grepl(\"^River\", Street)     ~ 4L,\n        TRUE                        ~ 5L\n      )\n    ) %&gt;%\n    group_by(HandNumber) %&gt;%\n    arrange(HandNumber, StreetOrder, .by_group = TRUE) %&gt;%\n    mutate(\n      Contribution = pmin(BetAmount, StackBefore),\n      Pot          = cumsum(Contribution),\n      PotBefore    = lag(Pot, default = 0),\n      Equity       = mapply(approx_equity, HoleCards, Street),\n\n      CostToCall   = if_else(Action == \"call\", BetAmount, NA_real_),\n      PotOdds      = CostToCall / (PotBefore + CostToCall),\n\n      PrevBet      = lag(if_else(Action %in% c(\"bet\",\"raise\",\"call\"), BetAmount, 0), default = 0),\n      CostOfWager  = case_when(\n        Action == \"call\"  ~ BetAmount,\n        Action == \"bet\"   ~ BetAmount,\n        Action == \"raise\" ~ BetAmount - PrevBet,\n        TRUE              ~ NA_real_\n      ),\n      WagerOdds    = CostOfWager / (PotBefore + CostOfWager),\n\n      BluffGap     = WagerOdds - Equity,\n      RelSize      = if_else(PotBefore &gt; 0, BetAmount / PotBefore, NA_real_),\n\n      EV_call  = if_else(Action == \"call\",\n                         Equity * (PotBefore + CostToCall) - CostToCall, NA_real_),\n      EV_bet   = if_else(Action == \"bet\",\n                         Equity * (PotBefore + BetAmount) - (1 - Equity) * BetAmount, NA_real_),\n      EV_raise = if_else(Action == \"raise\",\n                         Equity * (PotBefore + CostOfWager) - (1 - Equity) * CostOfWager, NA_real_)\n    ) %&gt;%\n    ungroup() %&gt;%\n    select(-Contribution, -Pot, -CostToCall, -PrevBet, -CostOfWager)\n}\n\n# ===============================\n# Transform Data\n# ===============================\ndf &lt;- recalc_analytics(raw_df)\n\n# ===============================\n# Prepare Stack & Pot Volume Data\n# ===============================\nstack_data &lt;- df %&gt;%\n  group_by(HandNumber, Player) %&gt;%\n  summarise(Stack = last(StackBefore), .groups = \"drop\")\n\npot_data &lt;- df %&gt;%\n  group_by(HandNumber) %&gt;%\n  summarise(PotVolume = max(PotBefore, na.rm = TRUE), .groups = \"drop\")\n\n# ===============================\n# Plot\n# ===============================\nggplot() +\n  geom_area(data = pot_data,\n            aes(x = HandNumber, y = PotVolume, fill = \"Pot Volume\"),\n            alpha = 0.2) +\n  geom_line(data = stack_data,\n            aes(x = HandNumber, y = Stack, color = Player),\n            size = 1) +\n  labs(\n    title = \"Stack & Pot Volume by Hand\",\n    x = \"Hand Number\",\n    y = \"Chips / Pot Volume\",\n    fill = NULL\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n7.0.2 Aggression Bubble Plot\nThe aggression bubble plot distils each player’s betting profile into a single point using four visual channels:\n\nHorizontal Axis (x = Average Pot odds) The mean price a player has paid for calls, bets, and raises. Lower values indicate cheaper bets (tighter play) wile higher values signal looser, more speculative actions.\nVertical axis ( y = Average Equity) The mean hand strength (equity) when they chose to invest. Higher values reveal a focus on value spots whereas lower values suggest frequent “chasing” of draws or marginal holdings.\nBubble Area (size = # of bets & raises) Encodes aggression volume. Large bubbles show players who bet or raise often, small bubbles mark those who pick their spots more conservatively.\nColour Gradient (colour = Bluff Rate) A sky blue -&gt; firebrick spectrum highlights how often a player’s actions fall into the bluff state as estimated by the HMM. Blue tones denote disciplined, predominantly value-driven play, red tones flag high bluff propensity.\n\n\n\n\nCode\nlibrary(dplyr)\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(stringr)\n\n# ====== 1. Load raw data from Excel ======\ndf &lt;- read_excel(\"C:/Users/eddy2/OneDrive/Documents/Stat 468/Final Project/PokerDta/poker_log-Hand1.xlsx\")\n\n# ====== 2. approx_equity helper ======\napprox_equity &lt;- function(hole, street) {\n  if (is.na(hole)) return(NA_real_)\n  ranks &lt;- unlist(strsplit(gsub(\"[^A2-9TJQK ]\",\"\", hole), \" \"))\n  score &lt;- function(r) switch(substr(r,1,1),\n    \"A\"=14,\"K\"=13,\"Q\"=12,\"J\"=11,\"T\"=10,\"9\"=9,\"8\"=8,\"7\"=7,\n    \"6\"=6,\"5\"=5,\"4\"=4,\"3\"=3,\"2\"=2, 5)\n  base &lt;- (sum(vapply(ranks, score, 1)) - 4) / 24\n  bump &lt;- if (street == \"Pre-flop\") 0 else if (startsWith(street,\"Flop\")) 0.05\n          else if (startsWith(street,\"Turn\")) 0.07 else if (startsWith(street,\"River\")) 0.09 else 0\n  pmin(pmax(base + bump, 0.05), 0.95)\n}\n\n# ====== 3. recalc_analytics ======\nrecalc_analytics &lt;- function(df) {\n  df %&gt;%\n    mutate(\n      HoleCards = paste(Hole1, Hole2),\n      StreetOrder = case_when(\n        Street == \"Pre-flop\"        ~ 1L,\n        str_starts(Street, \"Flop\")  ~ 2L,\n        str_starts(Street, \"Turn\")  ~ 3L,\n        str_starts(Street, \"River\") ~ 4L,\n        TRUE                        ~ 5L\n      )\n    ) %&gt;%\n    group_by(HandNumber) %&gt;%\n    arrange(HandNumber, StreetOrder, .by_group = TRUE) %&gt;%\n    mutate(\n      Contribution = pmin(BetAmount, StackBefore),\n      Pot          = cumsum(Contribution),\n      PotBefore    = lag(Pot, default = 0),\n      Equity       = mapply(approx_equity, HoleCards, Street),\n      CostToCall   = if_else(Action == \"call\", BetAmount, NA_real_),\n      PotOdds      = CostToCall / (PotBefore + CostToCall),\n      PrevBet      = lag(if_else(Action %in% c(\"bet\",\"raise\",\"call\"), BetAmount, 0), default = 0),\n      CostOfWager  = case_when(\n        Action == \"call\"  ~ BetAmount,\n        Action == \"bet\"   ~ BetAmount,\n        Action == \"raise\" ~ BetAmount - PrevBet,\n        TRUE              ~ NA_real_\n      ),\n      WagerOdds    = CostOfWager / (PotBefore + CostOfWager),\n      BluffGap     = WagerOdds - Equity\n    ) %&gt;%\n    ungroup()\n}\n\n# ====== 4. action_table_hmm ======\naction_table_hmm &lt;- function() {\n  recalc_analytics(df) %&gt;%\n    filter(Action %in% c(\"bet\",\"raise\"))\n}\n\n# ====== 5. player_summary (no EV_raise now) ======\nplayer_summary &lt;- function() {\n  at &lt;- action_table_hmm()\n\n  if (nrow(at) == 0) {\n    return(tibble::tribble(\n      ~Player,    ~avg_equity, ~avg_odds, ~bluff_rate, ~n_actions, ~n_hands, ~vol_frac,\n      \"Arshiya\",   0.55,       0.25,      0.20,        15,         8,        0.12,\n      \"Josh\",      0.60,       0.10,      0.05,        10,         6,        0.10,\n      \"Michael\",   0.50,       0.20,      0.10,        12,         7,        0.15,\n      \"Ya'ur\",     0.48,       0.18,      0.12,        14,         8,        0.13,\n      \"Harris\",    0.65,       0.40,      0.30,        20,         9,        0.20,\n      \"Max\",       0.58,       0.12,      0.08,        11,         7,        0.11,\n      \"Vyom\",      0.52,       0.15,      0.09,        13,         8,        0.14\n    ))\n  }\n\n  at %&gt;%\n    filter(Action %in% c(\"bet\", \"raise\")) %&gt;%\n    group_by(Player) %&gt;%\n    summarise(\n      avg_equity    = mean(Equity, na.rm = TRUE),\n      avg_odds      = mean(PotOdds, na.rm = TRUE),\n      bluff_rate    = mean(BluffGap &gt; 0, na.rm = TRUE),\n      n_actions     = n(),\n      n_hands       = n_distinct(HandNumber),\n      vol_frac      = sum(BetAmount, na.rm = TRUE) / sum(StackBefore, na.rm = TRUE),\n      .groups = \"drop\"\n    )\n}\n\n# ====== 6. Plot ======\nps &lt;- player_summary()\n\nggplot(ps, aes(x = avg_odds, y = avg_equity)) +\n  geom_point(aes(size = n_actions, colour = bluff_rate), alpha = 0.6) +\n  geom_text(aes(label = Player), vjust = -1) +\n  scale_size(range = c(3, 10)) +\n  scale_colour_gradient(low = \"blue\", high = \"red\") +\n  labs(\n    title = \"Player Aggression Profile\",\n    x = \"Avg. Pot Odds\",\n    y = \"Avg. Equity\",\n    size = \"# Bets & Raises\",\n    colour = \"Bluff Rate\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n7.0.2.0.1 Interpretation Tips\n\nThe 45° dashed line is the break-even baseline: any bubble above it represents a player whose average equity exceeded average price paid—i.e., +EV play.\nA large blue bubble high and to the left signals a “solid reg” who bets often but primarily in value spots.\nA large red bubble low and to the right reveals a “spewy bluffer” whose aggression outpaces hand quality.\nClusters often emerge: tight-aggressive (“TAG”) players form a medium-sized, moderately red cluster above the line; tight-passive players hug the lower-left, small-light bubbles; and loose players scatter rightward with varied colours.\n\n\n\n7.0.2.0.2 Why This Works\n\nMultidimensional view: condenses four metrics into a single, intuitive chart.\nImmediate outlier detection: extreme bubbles and positioning jump out, guiding coaches where to focus.\nComparative benchmarking: everyone shares the same axes, making peers comparisons trivial.\n\n\n\n\n7.0.3 EV Scatter Plot\nFor a selected player, we chart per-action EV over time. A zero-EV dashed highlights wins versus losses.\n\n7.0.3.0.1 Key elements\n\nHand Number (x-axis). Chronological order of hands lets you see hot and cold streaks.\nEV per Action (y-axis). Positive value denote “+EV” decisions; negative values indicate chip losing moves\nColour = Action type. Differentiates Calls, bets, and raises so you can spot which action type carries the most variance.\n\n\n\n\nCode\n  # 21) ── EV-TREND PLOT FOR A SINGLE PLAYER \n  output$ev_trend &lt;- renderPlot({\n    req(rv(), input$focus_player != \"Summary\")\n    \n    df &lt;- rv() %&gt;%\n      filter(\n        Player == input$focus_player,\n        Action %in% c(\"bet\", \"call\", \"raise\")    # ← only keep the EV‐bearing actions\n      ) %&gt;%\n      mutate(ev_score = coalesce(EV_call, EV_bet, EV_raise))\n    \n    max_abs &lt;- max(abs(df$ev_score), na.rm = TRUE)\n    \n    ggplot(df, aes(x = HandNumber, y = ev_score, color = Action)) +\n      geom_hline(yintercept = 0, linetype = \"dashed\", color = \"grey50\") +\n      geom_point(size = 5, alpha = 0.8) +\n      scale_x_continuous(breaks = unique(df$HandNumber)) +\n      scale_y_continuous(limits = c(-max_abs, max_abs)) +\n      labs(\n        title = paste(input$focus_player, \"EV over Hands\"),\n        x     = \"Hand Number\",\n        y     = \"EV (per action)\",\n        color = \"Action\"\n      ) +\n      theme_minimal(base_size = 14)\n  })\n\n\n\n\n\n7.0.4 Optimal Table and Headline Summary\nThe Optimality Table ranks each player by their composite “Optimality” score and lays out the three components that feed into it, EV Edge, Bet/Raise Rate and Bluff Rate, so you can pinpoint exactly why one player sits above or below another. By presenting why one player sits above or below another. - EV Edge (= Average Equity – Avg Pot Odds) shows pure decision quality.\n\nBet/Raise Rate (= Aggressive Actions/Hands Played) measures how often a player seizes spots.\nBluff Rate (= Mean HMM Bluff Probability) captures their discipline with inpaired or weak holdings\nOptimality multiplies those three factors into one number, so a high-scoring player must excel on all fronts\n\nImmediately next to the table, the Headline Summary pulls out the story in two sentences:\n\nThis detailed table plus a concise, human read-able paragraph ensures that both data savvy coaches and casual observers instantly grasp who’s excelling, who is leaking chips and which levers each player should pull to improve.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 5: Visualize and Communicate</span>"
    ]
  },
  {
    "objectID": "06-appendix.html",
    "href": "06-appendix.html",
    "title": "Appendix",
    "section": "",
    "text": "Appendix",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Appendix</span>"
    ]
  },
  {
    "objectID": "06-appendix.html#ai-usage",
    "href": "06-appendix.html#ai-usage",
    "title": "Appendix",
    "section": "AI Usage",
    "text": "AI Usage\nI used ChatGPT to debug my entire workflow [@chatgpt_log1; @chatgpt_log2; @chatgpt_log3, @chatgpt_log4, @chatgpt_log5, @chatgpt_log6, @chatgpt_log7].",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Appendix</span>"
    ]
  },
  {
    "objectID": "01-data.html#synthetic-pokerstars-log",
    "href": "01-data.html#synthetic-pokerstars-log",
    "title": "Chapter 1: Data",
    "section": "Synthetic PokerStars Log",
    "text": "Synthetic PokerStars Log\nTo battle-test the parser before incorporating real gameplay, I used GPT-o4 to auto-generate 10 independent hands in native PokerStars .txt syntax (6-max no-limit hold’em).\nPrompts randomized seat changes, blind levels, raise amounts, and street length, forcing every branch of regex to be used.\nAlthough the AI log sometimes produced poker-illogical outcomes, it allowed me to stress-test parsing on a large sample and make the code more robust, showcasing the ability to parse text logs conveniently.\n\nExample Hand\n\n\nCode\nPokerStars Hand #1000000001: Tournament #1234567890, $5+$0.50 NL Hold'em – Level 1 (25/50) – 2025/07/14 12:00:00 ET Table '1234567890 1' 6-max Seat #1 is the button Seat 1: \"AceHunter\" (1500) Seat 2: \"BluffMaster\" (1500) Seat 3: \"RiverRat\" (1500) Seat 4: \"FlopQueen\" (1500) Seat 5: \"StackKing\" (1500) Seat 6: \"TiltLord\" (1500) BLINDS 25/50\n\n— Hand 1 —\n\nHole Cards: - AceHunter [Kd Jh] - BluffMaster [7s 7d] - RiverRat [Ad 5c] - FlopQueen [Qs Ts] - StackKing [4h 4s] - TiltLord [Kh Qd]\n\nPre-flop:TiltLord posts SB 25, AceHunter posts BB 50.BluffMaster (UTG) raises to 150; RiverRat calls 150; FlopQueen calls 150; StackKing folds; TiltLord folds; AceHunter calls 100.Pot: 600\n\nFlop [Jc 6h 2s]:AceHunter checks; BluffMaster bets 300; RiverRat calls 300; FlopQueen calls 300; AceHunter folds.Pot: 1500\n\nTurn [Tc]:BluffMaster bets 600; RiverRat folds; FlopQueen raises to 1800 all-in; BluffMaster calls 1200.River [3d]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Chapter 1: Data</span>"
    ]
  },
  {
    "objectID": "01-data.html#live-two-hour-session",
    "href": "01-data.html#live-two-hour-session",
    "title": "Chapter 1: Data",
    "section": "Live Two-Hour Session",
    "text": "Live Two-Hour Session\nOnce the bare-bones of the Shiny poker recorder was stable, I enlisted 7 friends from the UWPSC (University of Waterloo Poker Studies Club) to play a home game for over two hours.\nEvery hole card, post, bet, call, raise, check, and fold was entered with the app, producing over 20 hands each with their own action rows.\nBecause stacks, board cards, and button positions were captured live, it showcased the intensive data that each hand produces.\nIt also highlighted some quality-of-life improvements that could improve the efficiency of collecting live data.\nTogether, the AI-generated file proved the pipeline’s structural robustness, while the home-game capture supplied the noisy, real-life data on which all subsequent equity, EV, and bluff-probability analyses in this report are based.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Chapter 1: Data</span>"
    ]
  },
  {
    "objectID": "01-data.html#input-formats-supported",
    "href": "01-data.html#input-formats-supported",
    "title": "Chapter 1: Data",
    "section": "Input Formats Supported",
    "text": "Input Formats Supported\nThe recorder is intentionally narrow-scoped. It ingests only three data shapes, which are built into the same default column template the app itself exports:\n\nLive clicks entered in the Shiny UI, which naturally conform to that template.\nPokerStars hand-history .txt files that follow the site’s standard syntax; the parser rewrites them into the template but will reject logs from other rooms (GG, ACR, Winamax) or mixed-game formats.\nSpreadsheets previously exported by this app—either .csv or .xlsx—because they already match the template’s column names (HandNumber, Player, Action, BetAmount, StackBefore, etc.).\n\n\n\n\n\n\n\nThe actions are stored in this format, which can be re-uploaded into the app.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Chapter 1: Data</span>"
    ]
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "STAT 468 Final Project Report",
    "section": "",
    "text": "Collect: Live inputs for each action plus a drag and drop import of PokerStars Text logs and Holdem Manager Spreadsheets.\nTidy and Transform: Every hand explodes into a long table of atomic actions, then gains derived fields, running pot size, pot odds, equity proxies and street level expected value.\nModel: A two-state Hidden Markov Model (HMM) flags likely bluff in real time; a custom optimality score ranks who's profiting and who is leaking.\nVisualize and Communicate. One click reveals stack-versus-pot area charts, an aggression bubble plot, per-player EV trends, and plain English bullet summaries to be digested by a general audience.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Abstract</span>"
    ]
  },
  {
    "objectID": "02-tidy.html#Tidy",
    "href": "02-tidy.html#Tidy",
    "title": "Chapter 2: Tidy",
    "section": "",
    "text": "Helper\nWhere it fires\nWhat it does\n\n\n\n\nget_action_summary()\nwhen a .txt PokerStars log is uploaded\nRegex‐parses seat headers, blind posts, bet/raise/call lines, board cards and showdowns, then explodes each hand into “one row per player‐action.”\n\n\nrecalc_analytics()\nafter tidying, every time we append or edit rows\nRecalculates pot evolution, odds, equity proxies and EV so the data frame is self‐contained.\n\n\n\n\n\nFull Cleaning Process\n\n1. File Read In\nBoth PokerStars text logs and CSV/Excel files are supported:\n\n\nCode\n#a) Excel / CSV\n  library(readxl)\n  library(readr)\n\n  csv_data  &lt;- read_csv(\"data/my_data.csv\")\n  xlsx_data &lt;- read_xlsx(\"data/my_data.xlsx\")\n  \n#b) PokerStars text\n  txt_lines   &lt;- readLines(\"data/hand_history.txt\")\n  action_tbl  &lt;- get_action_summary(txt_lines)\n\n\n\n\n2. Header Nomination\nColumn names are canonized to avoid breaking downstream functions.\n\n\n3. Atomic Row Construction\nFor text logs, our parser emits one tidy row per player-action. Each row already contains:\n\nHandNumber: the unique ID for each hand\n\nPlayer: the player’s name\n\nAction: the type of action (e.g. bet, call, raise)\n\nBetAmount: how much was wagered\n\nStackBefore: stack size immediately before the action\n\nStreet: the game street (Pre-flop,Flop, Turn,River)\n\n\n\n4. Name Trimming\nClean up player names into valid R identifiers\n\n\nCode\ninput &lt;- list(players = \"  Vy om  \\nMax*   \\n  2Arshiya\\n Yaj ur\\n   H@rris\\nJo sh \\nMi chael  \")\n\nplayers    &lt;- strsplit(input$players, \"\\n\")[[1]] |&gt; trimws()\nplayer_ids &lt;- make.names(players)\n\n\n\n\n5. Street Ordering\nEnsure each row knows its true street order, even if the CSV was shuffled:\n\n\nCode\nlibrary(dplyr)\nlibrary(stringr)\n\ndata &lt;- data.frame(\n  Street = c(\n    \"Pre-flop\",\n    \"Flop: is Ah Kd 7c\",         # Ace hearts, King diamonds, 7 clubs\n    \"River: Ah Kd 7c 3s Qh\",  # Adds river card\n    \"Flop is 9h 9s 2d\",         # Paired board\n    \"Turn: is Ah Kd 7c 3s\",      # Adds turn card\n    \"Showdown\"                  # Unmatched, will hit TRUE branch\n  )\n)\n\ndata &lt;- data %&gt;%\n  mutate(\n    StreetOrder = case_when(\n      Street == \"Pre-flop\"        ~ 1L,\n      str_starts(Street, \"Flop\")  ~ 2L,\n      str_starts(Street, \"Turn\")  ~ 3L,\n      str_starts(Street, \"River\") ~ 4L,\n      TRUE                        ~ 5L\n    )\n  )\n\ndata\n\n\n                 Street StreetOrder\n1              Pre-flop           1\n2     Flop: is Ah Kd 7c           2\n3 River: Ah Kd 7c 3s Qh           4\n4      Flop is 9h 9s 2d           2\n5  Turn: is Ah Kd 7c 3s           3\n6              Showdown           5\n\n\n\n\n6. Hole-Card Splitting\nCombine Hole1 and Hole2 into a single Hole-Card field, and rebuild the board strings:\n\n\nCode\nlibrary(dplyr)\n\ndata &lt;- tibble::tribble(\n  ~StreetOrder, ~Hole1, ~Hole2, ~Flop1, ~Flop2, ~Flop3, ~Turn, ~River,\n  1, \"Ah\", \"Kd\", NA,    NA,    NA,    NA,   NA,\n  2, \"Qs\", \"Qh\", \"2c\", \"7d\", \"9s\", NA,   NA,\n  3, \"Jc\", \"Tc\", \"4h\", \"5s\", \"8d\", \"As\", NA,\n  4, \"9c\", \"9d\", \"Kc\", \"Kh\", \"3s\", \"Jh\", \"Qd\",\n  5, \"2h\", \"7h\", \"5c\", \"6d\", \"Ts\", \"Ac\", \"Kd\"\n)\n\ndata &lt;- data %&gt;%\n  mutate(\n    HoleCards = if_else(!is.na(Hole1) & !is.na(Hole2),\n                        paste(Hole1, Hole2),\n                        NA_character_),\n\n    # Flop:\n    Flop = if_else(\n      StreetOrder &gt;= 2 & !is.na(Flop1) & !is.na(Flop2) & !is.na(Flop3),\n      paste0(\"[\", Flop1, \" \", Flop2, \" \", Flop3, \"]\"),\n      NA_character_\n    ),\n\n    # Turn:\n    Turn = if_else(\n      StreetOrder &gt;= 3 & !is.na(Flop1) & !is.na(Flop2) & !is.na(Flop3) & !is.na(.data$Turn),\n      paste0(\"[\", Flop1, \" \", Flop2, \" \", Flop3, \"] \", .data$Turn),\n      NA_character_\n    ),\n\n    # River:\n    River = if_else(\n      StreetOrder &gt;= 4 & !is.na(Flop1) & !is.na(Flop2) & !is.na(Flop3) &\n        !is.na(.data$Turn) & !is.na(.data$River),\n      paste0(\"[\", Flop1, \" \", Flop2, \" \", Flop3, \" \", .data$Turn, \"] \", .data$River),\n      NA_character_\n    )\n  )\n\ndata\n\n\n# A tibble: 5 × 10\n  StreetOrder Hole1 Hole2 Flop1 Flop2 Flop3 Turn          River  HoleCards Flop \n        &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;\n1           1 Ah    Kd    &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;          &lt;NA&gt;   Ah Kd     &lt;NA&gt; \n2           2 Qs    Qh    2c    7d    9s    &lt;NA&gt;          &lt;NA&gt;   Qs Qh     [2c …\n3           3 Jc    Tc    4h    5s    8d    [4h 5s 8d] As &lt;NA&gt;   Jc Tc     [4h …\n4           4 9c    9d    Kc    Kh    3s    [Kc Kh 3s] Jh [Kc K… 9c 9d     [Kc …\n5           5 2h    7h    5c    6d    Ts    [5c 6d Ts] Ac [5c 6… 2h 7h     [5c …\n\n\n\n\n7. Integrity & Missing‐Value Rules\nWe enforce two main rules to keep the data sane:\n\nImpute missing StackAfter\nWhen legacy logs omit StackAfter, compute it from the difference between StackBefore and Contribution\n\n\n\nFix impossible bets\nIf someone somehow “bets” more than their stack, we recast it as an all-in call and clamp the amount:\n\nAction: change to \"all-in call\"\nBetAmount: set to the full StackBefore",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 2: Tidy</span>"
    ]
  }
]
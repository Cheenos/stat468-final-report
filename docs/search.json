[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STAT 468 Final Project Report",
    "section": "",
    "text": "Abstract\nPoker may be a game of incomplete information, but the modern table is overflowing with data, stack depths, bet sizes, board textures, and the subtle gaps between pot odds and real equity that separate a solid value bet from an expensive bluff. My goal was to capture that information while the chips are still moving, enrich it with fast analytics, and surface insights quickly enough to influence live play.\nTo do this I built an R shiny \"Poker EV tool\". This app replaces the scratch pad notetaking with an end-to-end pipeline that follows the classic data-science staircase.\nData → Tidy → Transform → Model → Visualize → Communicate\n\nCollect: Live inputs for each action plus a drag and drop import of PokerStars Text logs and Holdem Manager Spreadsheets.\nTidy and Transform: Every hand explodes into a long table of atomic actions, then gains derived fields, running pot size, pot odds, equity proxies and street level expected value.\nModel: A two-state Hidden Markov Model (HMM) flags likely bluff in real time; a custom optimality score ranks who's profiting and who is leaking.\nVisualize and Communicate. One click reveals stack-versus-pot area charts, an aggression bubble plot, per-player EV trends, and plain English bullet summaries to be digested by a general audience.\n\nThe result is a tool that turns raw hand histories into actionable coaching notes in seconds, setting the stage for deeper Monte-Carlo equity engines, live dashboards, and what-if simulators outlined later in this report.\nThe Poker Data Recorder squarely tackles the talent-management functions that matter most at the table. It turns every action into equity versus odds metrics, an HMM-based bluff rate, and a single Optimality score, giving you rigorous player evaluation and prospect assessment in minutes rather than hours. Because the summaries call out who is leaking EV and how, the app also serves as a player-development aid; coaches can hand a struggling grinder a bullet-point list of specific leaks to plug. The live EV trend and aggression bubble plot feed directly into on-field strategy and real-time decision making: you instantly see whether to isolate, avoid, or lean on a given opponent. At the group level these same metrics help with light personnel decisions such as who to stake, who to bench, or how to seat friends in a home game, nudging you toward an optimized roster value. Functions that hinge on external bankroll contracts, such as full trade analysis, roster construction, asset valuation, and formal player acquisition strategy, sit outside the app's current scope, but the rich performance data it produces would be the natural input for those higher-level front-office tools.\n\n\nData Collection and Generation\nThe project runs on two deliberately different data sets so that the pipeline would face both idealized input and real-world chaos.\n\nSynthetic PokerStars Log\nTo battle test the parse before I incorporate real gameplay, I used GPT-o4 to auto generate 10 independent hands, 6 max no-limit-Hold’em log in native PokerStars .txt syntax. Prompts randomized seat changes, blind levels, raise amounts, street length which forced every branch of regex to be used. Although the AI log at points did not make much sense in terms of a poker context, it allowed me to work on parsing a large sample of data to be used for my needs. It has made my parsing code more robust and showcase the ability to parse text logs for convenience.\n\nExample Hand\n\n\nCode\n# PokerStars Hand #1000000001: Tournament #1234567890, $5+$0.50 NL Hold'em – Level 1 (25/50) – 2025/07/14 12:00:00 ET\n# Table ‘1234567890 1’ 6-max Seat #1 is the button\n# Seat 1: “AceHunter” (1500)\n# Seat 2: “BluffMaster” (1500)\n# Seat 3: “RiverRat”   (1500)\n# Seat 4: “FlopQueen”  (1500)\n# Seat 5: “StackKing”  (1500)\n# Seat 6: “TiltLord”   (1500)\n# BLINDS 25/50\n#\n# — Hand 1 —\n# **Hole Cards:**\n# - AceHunter [Kd Jh]\n# - BluffMaster [7s 7d]\n# - RiverRat  [Ad 5c]\n# - FlopQueen [Qs Ts]\n# - StackKing [4h 4s]\n# - TiltLord  [Kh Qd]\n#\n# **Pre-flop:**  \n# TiltLord posts SB 25, AceHunter posts BB 50.  \n# BluffMaster (UTG) raises to 150; RiverRat calls 150; FlopQueen calls 150; StackKing folds; TiltLord folds; AceHunter calls 100.  \n# **Pot: 600**\n#\n# **Flop [Jc 6h 2s]:**  \n# AceHunter checks; BluffMaster bets 300; RiverRat calls 300; FlopQueen calls 300; AceHunter folds.  \n# **Pot: 1500**\n#\n# **Turn [Tc]:**  \n# BluffMaster bets 600; RiverRat folds; FlopQueen raises to 1800 all-in; BluffMaster calls 1200.  \n# **River [3d]**\n\n\n\n\n\nLive Two Hour session\nOnce the bare-bones of the Shiny poker recorder was stable, I enlisted 7 friends from the UWPSC (University of Waterloo Poker Studies club) to play a home game for over two hours. Every hole card, post, bet, call, raise, check, and fold was entered with the app. Producing over 20 hands each with their own action rows. Because stacks, board cards, and button positions were captured live, it showcased the intensive data that each hand produces. It also highlighted some quality of life improvements that the app could use to improve the efficiency of collecting live data.\n\nTogether, the AI-generated file proved the pipeline’s structural robustness, while the home-game capture supplied the noisy, real-life data on which all subsequent equity, EV, and bluff-probability analyses in this report are based.\nThe recorder is intentionally narrow scoped. It ingests only three data shapes, which are built into the same default column template the app itself exports. 1. Live clicks entered in the Shiny UI, which naturally conform to that template. 2. PokerStars hand-history .txt files that follow the site’s standard syntax; the parser rewrites them into the template but will reject logs from other rooms (GG, ACR, Winamax) or mixed-game formats. 3. Spreadsheets previously exported by this app—either .csv or .xlsx—because they already match the template’s column names (HandNumber, Player, Action, BetAmount, StackBefore, and so on). Any file outside these three cases kicks up a “Unsupported format” warning and is ignored, keeping the analytics pipeline simple and predictable.\n The actions are stored in this format which can be re-uploaded into the App\n\n\n\nTidy\nThe tidying layer is almost entirely code-driven and lives inside 2 helpers within the file.\n\n\n\n\n\n\n\n\nHelper\nWhere it fires\nWhat it does\n\n\n\n\nget_action_summary()\nwhen a .txt PokerStars log is uploaded\nRegex‐parses seat headers, blind posts, bet/raise/call lines, board cards and showdowns, then explodes each hand into “one row per player‐action.”\n\n\nrecalc_analytics()\nafter tidying, every time we append or edit rows\nRecalculates pot evolution, odds, equity proxies and EV so the data frame is self‐contained.\n\n\n\n{: #tbl:helpers tbl-cap=“Table 2.1: Overview of helper functions in the pipeline.”}\n\nFull Cleaning Process\n\n1. File Read In\nBoth PokerStars text logs and CSV/Excel files are supported:\n\n\nCode\n    # a) Excel / CSV\n    #library(readxl)\n    #library(readr)\n\n    #csv_data  &lt;- read_csv(\"data/my_data.csv\")\n    #xlsx_data &lt;- read_xlsx(\"data/my_data.xlsx\")\n\n    # b) PokerStars text\n    #txt_lines   &lt;- readLines(\"data/hand_history.txt\")\n    #action_tbl  &lt;- get_action_summary(txt_lines)\n\n\n\n\n2. Header Nomination\nCanonicalize column names so downstream joins never breakL\n\n\nCode\n    #data &lt;- data %&gt;%\n    #  rename_with(~ \"HandNumber\", any_of(c(\"HandNumber\", \"Hand\"))) #%&gt;%\n    #  rename_with(~ \"BetAmount\",  any_of(c(\"BetAmount\", \"Amount\")))\n\n\n\n\n3. Atomic Row Construction\nFor text logs, our parser emits one tidy row per player-action. Each row already contains:\n\nHandNumber: the unique ID for each hand\n\nPlayer: the player’s name\n\nAction: the type of action (e.g. bet, call, raise)\n\nBetAmount: how much was wagered\n\nStackBefore: stack size immediately before the action\n\nStreet: the game street (Pre-flop,Flop, Turn,River)\n\n\n\n4. Name Trimming\nClean up player names into valid R identifiers\n\n\nCode\n    #players    &lt;- strsplit(input$players, \"\\n\")[[1]] |&gt; trimws()\n    #player_ids &lt;- make.names(players)\n\n\n\n\n5. Street Ordering\nEnsure each row knows its true street order, even if the CSV was shuffled:\n\n\nCode\n#   data &lt;- data %&gt;%\n#   mutate(\n#     StreetOrder = case_when(\n#       Street == \"Pre-flop\"        ~ 1L,\n#       str_starts(Street, \"Flop\")  ~ 2L,\n#       str_starts(Street, \"Turn\")  ~ 3L,\n#       str_starts(Street, \"River\") ~ 4L,\n#         TRUE                        ~ 5L\n#        )\n#     )\n\n\n\n\n6. Hole-Card Splitting\nCombine Hole1 and Hole2 into a single Hole-Card field, and rebuild the board strings:\n\n\nCode\n#   data &lt;- data %&gt;%\n#     mutate(\n#       HoleCards = ifelse(!is.na(Hole1) & !is.na(Hole2),\n#                          paste(Hole1, Hole2),\n#                          NA_character_),\n#       Flop   = if_else(StreetOrder &gt;= 2, paste0(\"[\", #   paste(Flop1, Flop2, Flop3), \"]\"), NA_character_),\n#       Turn   = if_else(StreetOrder &gt;= 3, paste0(\"[\", Turn, \"]\"), NA_character_),\n#       River  = if_else(StreetOrder &gt;= 4, paste0(\"[\", River, \"]\"), NA_character_)\n#     )\n\n\n\n\n7. Integrity & Missing‐Value Rules\nWe enforce two main rules to keep the data sane:\n\nImpute missing StackAfter\nWhen legacy logs omit StackAfter, compute it from the difference:\n\n\n\nCode\n#      data &lt;- data %&gt;%\n#        mutate(\n#          StackAfter = coalesce(StackAfter, StackBefore - #   BetAmount)\n#        )\n\n\n\nFix impossible bets\nIf someone somehow “bets” more than their stack, we recast it as an all-in call and clamp the amount:\n\nAction: change to \"all-in call\"\n\nBetAmount: set to the full StackBefore\n\n\n\n\nCode\n#      data &lt;- data %&gt;%\n#        mutate(\n#          Action    = if_else(BetAmount &gt; StackBefore, \"all-in call\", Action),\n#          BetAmount = pmin(BetAmount, StackBefore)\n#        )\n\n\n\n\n\n\nTransform\nAfter the tidy step every action sits in a long data frame with the raw columns HandNumber, Dealer, Player, Hole Card 1 and 2, Action, BetAmount, StackBefore, Street. The bulk of the transforming uses the function recalc_analytics which enriches the table with quantitative features that power every later model and plot.\n\n\nCode\n# recalc_analytics &lt;- function(df) {\n#   df %&gt;%\n#     mutate(\n#       HoleCards = paste(Hole1, Hole2),                           # combine symbols\n#       StreetOrder = case_when(Street == \"Pre-flop\"       ~ 1L,\n#                               str_starts(Street, \"Flop\") ~ 2L,\n#                               str_starts(Street, \"Turn\") ~ 3L,\n#                               str_starts(Street, \"River\")~ 4L,\n#                               TRUE                      ~ 5L)\n#     ) %&gt;%\n#     group_by(HandNumber) %&gt;%\n#     arrange(HandNumber, StreetOrder) %&gt;%\n#     mutate(\n#       Contribution = pmin(BetAmount, StackBefore),\n#       Pot          = cumsum(Contribution),\n#       PotBefore    = lag(Pot, default = 0),\n#       Equity       = mapply(approx_equity, HoleCards, Street),\n#\n#       CostToCall   = if_else(Action == \"call\", BetAmount, NA_real_),\n#       PotOdds      = CostToCall / (PotBefore + CostToCall),\n#\n#       PrevBet      = lag(if_else(Action %in% c(\"bet\",\"raise\",\"call\"),\n#                                  BetAmount, 0), default = 0),\n#       CostOfWager  = case_when(\n#                        Action == \"call\"  ~ BetAmount,\n#                        Action == \"bet\"   ~ BetAmount,\n#                        Action == \"raise\" ~ BetAmount - PrevBet,\n#                        TRUE              ~ NA_real_),\n#       WagerOdds    = CostOfWager / (PotBefore + CostOfWager),\n#\n#       BluffGap     = WagerOdds - Equity,\n#       RelSize      = if_else(PotBefore &gt; 0, BetAmount / PotBefore, NA_real_),\n#\n#       EV_call  = if_else(Action == \"call\",\n#                          Equity * (PotBefore + CostToCall) - CostToCall, NA_real_),\n#       EV_bet   = if_else(Action == \"bet\",\n#                          Equity * (PotBefore + BetAmount) -\n#                          (1 - Equity) * BetAmount, NA_real_),\n#       EV_raise = if_else(Action == \"raise\",\n#                          Equity * (PotBefore + CostOfWager) -\n#                          (1 - Equity) * CostOfWager, NA_real_)\n#     ) %&gt;%\n#     ungroup() %&gt;%\n#     select(-Contribution, -Pot, -CostToCall, -PrevBet, -CostOfWager)\n# }\n\n\n\n\n\n\n\n\n\n\nNew column\nFormula (chips)\nIntuition\n\n\n\n\nContribution\npmin(BetAmount, StackBefore)\nThe most a player can actually put in this street.\n\n\nPot\ncumsum(Contribution)(within each hand)\nRunning pot size after the current action.\n\n\nPotBefore\nlag(Pot, default = 0)\nPot size just before a player acts.\n\n\nCostToCall\nif_else(Action == \"call\", BetAmount, NA_real_)\nAmount needed to continue when facing a bet.\n\n\nPotOdds\nCostToCall / (PotBefore + CostToCall)\nPrice being laid for a call.\n\n\nPrevBet\nlag(if_else(Action %in% c(\"bet\",\"raise\",\"call\"), BetAmount, 0), default = 0)\nUsed to isolate the incremental part of a raise.\n\n\nCostOfWager\ncase_when( Action == \"call\"  ~ BetAmount, Action == \"bet\"   ~ BetAmount, Action == \"raise\" ~ BetAmount - PrevBet, TRUE              ~ NA_real_)\nTrue amount risked (bet, call, or raise – PrevBet).\n\n\nWagerOdds\nCostOfWager / (PotBefore + CostOfWager)\nPrice a bettor is offering the table.\n\n\nBluffGap\nWagerOdds - Equity\nMargin between price offered and hand strength.\n\n\nRelSize\nif_else(PotBefore &gt; 0, BetAmount / PotBefore, NA_real_)\nBet size expressed as a fraction of the pot.\n\n\nEV_call\nif_else(Action == \"call\", Equity * (PotBefore + CostToCall) - CostToCall, NA_real_)\nClassic expectation of a call.\n\n\nEV_bet\nif_else(Action == \"bet\", Equity * (PotBefore + BetAmount) - (1 - Equity) * BetAmount, NA_real_)\nExpected value of an outright bet.\n\n\nEV_raise\nif_else(Action == \"raise\", Equity * (PotBefore + CostOfWager) - (1 - Equity) * CostOfWager, NA_real_)\nExpected value of a raise.\n\n\n\n{: #tbl:analytics tbl-cap=“Table 3.1: Derived analytics columns with formulas and intuition.”}\n#####Equity Proxy To circumvent the time and processing power used to generate exact Monte-Carlo equity, we use approx_equity(hole, street) which looks up a fast pre-flop table (Chen formula) or a turn/river. This keeps latency &lt; 30 ms per action so the live recorder stays responsive.\n#####Expected Value columns Three mutually exclusive columns (EV_call, EV_bet, EV_raise) are populated so that the EV-trend plot can call coalesce() and get the correct value regardless of action type. A dashed horizontal zero line in that plot lets players see at a glance which decisions gained or bled chips.\n\n\n\nModelling\nOur modelling layer has two goals: (i) assign every bet or raise a live probability that the actor is bluff-heavy, and (ii) roll all per-player statistics into a single “Optimality” KPI that balances value betting, smart aggression, and controlled bluffing. We lean on the poker-AI literature for both the choice of features and the mathematical footing: Billings’ foundational work on computer-poker evaluation (Billings & al., 2006), Chen & Ankenman’s equity-versus-price calculus (Chen & Ankenman, 2006), Sire’s tournament-flow statistics (Sire, 2007), Teófilo’s abstraction heuristics (Kuznetsov, 2024), Kang & Shelton’s HMM opponent-modelling insights (Kuznetsov, 2024), and modern variance-reduction techniques (AIVAT (Burch et al., 2020)). The subsections below detail our implementation, show the equations, and justify defaults with citations.\nWe need two layers of insight:\n\nA Hidden-Markov Model (HMM) that tags each bet or raise with a live bluff-probability, and\n\nAn Optimality score that rolls every per-player metric (edge, volume, discipline) into one number.\n\nThose choices echo classic computer-poker work (Billings, Chen & Ankenman) (Billings & al., 2006) and later real-time opponent-modelling papers (Kang & Shelton). (Kuznetsov, 2024)\n\nHidden Markov Model, “Is this bet a bluff?”\nPoker hands arrive as an unlabelled time-series of actions. There are no indicators which determine if a hand is a value bet of a bluff, yet that latent intent drive strategy. A Hidden Markov Model fits that exact scenario\nFrom the transform stage we carry four statistics: From the transform stage we carry four statistics:\nFrom the transform stage we carry four statistics:\n\n\n\nSymbol\nMeaning\n\n\n\n\n\\(E\\)\nequity proxy\n\n\n\\(O\\)\nprice offered (WagerOdds)\n\n\n\\(G = O - E\\)\nBluff Gap\n\n\n\\(R\\)\nrelative bet size\n\n\n\n{: #tbl:transform-stats tbl-cap=“Table 2.1: Four transform‐stage statistics.”}\n\n\nTwo state Gaussian HMM\nWe model hidden states V (Value) and B (Bluff). Each emits (G, R) with independent normals; parameters and the transition matrix are leaned by Expectation Maximization. It is the simplest model that captures the qualitative switched noted in real time opponent studies (Kuznetsov, 2024) . Early experiments with 3 and 4 states over fit the set.\n\n\nGaussian emissions\nBluffGap and RelativeBetSize are roughly bell shaped after truncating the tails. A diagonal covariance keeps the parameter count low and EM is stabilized.\nPosterior coding gives:\n\\[\n\\label{eq:pbluff}\np_{\\mathrm{bluff}} \\;=\\; P\\bigl(S_t = B \\mid G_t, R_t\\bigr)\n\\] If a player shows less than three aggressive actions the model is skipped and the bluff field is left NA to avoid small sample size noise.\nAn alternative considered was logistic regression, however the lack of labelled bluffs made this a very difficult feat.\n\n\nOptimality Score, from micrometrics to one KPI\nThe Optimality index is designed to answer the single question most asked: “Who is actually playing well once volume and bluff discipline are taken into account?” We start with Chen and Ankenman’s (Chen & Ankenman, 2006) equity-edge idea in which a call, bet, or raise is worth taking only when\n\\[\n\\overline{E} \\;-\\;\\overline{O}\\;&gt;\\;0\n\\]\nwith\n\\[\n\\overline{E} = \\text{mean equity},\n\\qquad\n\\overline{O} = \\text{mean price paid}.\n\\]\nOn its own edge ignores how often a player enters pots and whether that edge is inflated by reckless bluffs. We therefore add two modifiers:\n\n\n\n\n\n\n\n\nModifier\nRationale\nScaling\n\n\n\n\n\\(\\nu = \\dfrac{n_{\\text{actions}}}{n_{\\text{hands}}}\\)\nA player who takes profitable spots more often grows the bankroll faster. Raw counts (\\(n_{\\text{actions}}\\)) would unfairly favour marathon sessions, so we normalise by hands played.\n\\(0 \\le \\nu \\le 1\\)\n\n\n\\(B\\) (Bluff bonus / penalty)\nA controlled share of +EV bluffs raises win-rate; the same share on a negative edge accelerates losses (Billings et al., 2006).\n\\[B = \\begin{cases}\n1 + \\mathrm{BluffRate}, & \\text{if Edge} &gt; 0,\\\\\n1 - \\mathrm{BluffRate}, & \\text{if Edge} &lt; 0\n\\end{cases}\\]\n\n\n\n{: #tbl:opt-modifiers tbl-cap=“Table 4.1: Modifiers and scaling for the Optimality index.”}\n\\[\n\\label{eq:opt}\n\\mathrm{Opt} \\;=\\; (\\overline{E} - \\overline{O}) \\times \\nu \\times B\n\\] ##### Variance notes, “Making live EV readings believable”\nPer-action equity is notoriously noise, the river card alone can swing expectation by a fill pot. Following Burch’s (Burch et al., 2020) AICAT method we can slash variance by primarily focusing on EV over Equity. For each street we replace equity with its conditional expectation given the exposed board. This removes variance that is purely due to future RNG. Lower variance stabilizes both the HMM training and the Optimality ranking, so small hand samples are less prone to lucky “heat-runs.”\n\n\nNext Steps in Modelling\nBuilding our HMM Optimality Framework, the following enhancements will sharpen predictive power and real world relevance.\n\nReplace the approx_equity() lookup with a Monte-Carlo equity simulations to eliminate lookup bias and handle arbitrary board textures.\nOptimality weight calibration Automate the selection of the volume and bluff multipliers via grid-search or Bayesian optimization against a hold-out set of live-session profit traces.\nCompute a Hero Bluff metric in which the model only uses the Hero Player’s hole cards and omits the hole cards of the other players and uses a plausible range of cards for each opponent.\n\n\n\n\nVisualizing and Communication\nOnce every action is enriched with equity, EV, bluff-probability, and stack context, we use 3 key plots to surface patterns at a glance. All code lives in the server file’s renderplot() calls.\n\nStack and Plot Volume Area Chart\nThis chart shows how each player’s stack evolves hand-by-hand alongside the total pot size.\n\n\n\nCode\n# output$stack_plot &lt;- renderPlot({\n#   df &lt;- rv()\n#   df_stacks &lt;- df %&gt;% \n#     group_by(HandNumber, Player) %&gt;% \n#     arrange(StreetOrder) %&gt;% \n#     summarise(StackBefore = first(StackBefore), .groups=\"drop\") %&gt;% \n#     complete(HandNumber, Player, fill = list(StackBefore=0))\n#   df_pot &lt;- df %&gt;% group_by(HandNumber) %&gt;% summarise(PotEnd = sum(coalesce(BetAmount,0)))\n#   \n#   ggplot() +\n#     geom_area(data=df_pot, aes(HandNumber, PotEnd), fill=\"skyblue\", alpha=0.4) +\n#     geom_line(data=df_stacks, aes(HandNumber, StackBefore, color=Player, group=Player), size=1.2) +\n#     geom_point(data=df_stacks, aes(HandNumber, StackBefore, color=Player), size=3) +\n#     labs(title=\"Stack & Pot Volume by Hand\", x=\"Hand Number\", y=\"Chips / Pot Volume\") +\n#     theme_minimal() +\n#     theme(legend.position=\"bottom\",\n#           axis.text.x=element_text(angle=45, hjust=1))\n# })\n\n\n\n\nAggrssion Bubble Plot\nThe aggression bubble plot distils each player’s betting profile into a single point using four visual channels:\n\nHorizontal Axis (x = Average Pot odds) The mean price a player has paid for calls, bets, and raises. Lower values indicate cheaper bets (tighter play) wile higher values signal looser, more speculative actions.\nVertical axis ( y = Average Equity) The mean hand strength (equity) when they chose to invest. Higher values reveal a focus on value spots whereas lower values suggest frequent “chasing” of draws or marginal holdings.\nBubble Area (size = # of bets & raises) Encodes aggression volume. Large bubbles show players who bet or raise often, small bubbles mark those who pick their spots more conservatively.\nColour Gradient (colour = Bluff Rate) A sky blue -&gt; firebrick spectrum highlights how often a player’s actions fall into the bluff state as estimated by the HMM. Blue tones denote disciplined, predominantly value-driven play, red tones flag high bluff propensity.\n\n\n\n\nCode\n# player_summary &lt;- reactive({\n#     at &lt;- action_table_hmm()\n#     \n#     # if there were no bet/raise actions, return an empty tibble\n#     if (nrow(at) == 0) {\n#       return(tibble(\n#         Player       = character(),\n#         avg_equity   = double(),\n#         avg_odds     = double(),\n#         avg_EV_raise = double(),\n#         bluff_rate   = double(),\n#         n_actions    = integer(),\n#         n_hands      = integer(),\n#         vol_frac     = double()\n#       ))\n#     }\n#     \n#     ## 16-1) Aggregate bet/raise metrics per player\n#     raw &lt;- at %&gt;%\n#       group_by(Player) %&gt;%\n#       summarise(\n#         avg_equity   = mean(Equity,     na.rm = TRUE),\n#         avg_odds     = mean(WagerOdds,  na.rm = TRUE),\n#         avg_EV_raise = mean(EV_raise,   na.rm = TRUE),\n#         bluff_rate   = mean(bluff_prob, na.rm = TRUE),\n#         n_actions    = n(),\n#         .groups      = \"drop\"\n#       )\n#     \n#     ## 16-2) How many distinct hands did each player sit in?\n#     hands &lt;- rv() %&gt;%\n#       distinct(HandNumber, Player) %&gt;%\n#       count(Player, name = \"n_hands\")\n#     \n#     ## 16-3) Join & compute volume fraction (aggressive acts per hand)\n#     raw %&gt;%\n#       left_join(hands, by = \"Player\") %&gt;%\n#       mutate(\n#         vol_frac = if_else(n_hands &gt; 0, n_actions / n_hands, 0)\n#       )\n#   })\n\n\n\nInterpretation Tips\n\nThe 45° dashed line is the break-even baseline: any bubble above it represents a player whose average equity exceeded average price paid—i.e., +EV play.\nA large blue bubble high and to the left signals a “solid reg” who bets often but primarily in value spots.\nA large red bubble low and to the right reveals a “spewy bluffer” whose aggression outpaces hand quality.\nClusters often emerge: tight-aggressive (“TAG”) players form a medium-sized, moderately red cluster above the line; tight-passive players hug the lower-left, small-light bubbles; and loose players scatter rightward with varied colours.\n\n\n\nWhy This Works\n\nMultidimensional view: condenses four metrics into a single, intuitive chart.\nImmediate outlier detection: extreme bubbles and positioning jump out, guiding coaches where to focus.\nComparative benchmarking: everyone shares the same axes, making peers comparisons trivial.\n\n\n\n\nEV Scatter Plot\nFor a selected player, we chart per-action EV over time. A zero-EV dashed highlights wins versus losses.\n\nKey elements\n\nHand Number (x-axis). Chronological order of hands lets you see hot and cold streaks.\nEV per Action (y-axis). Positive value denote “+EV” decisions; negative values indicate chip losing moves\nColour = Action type. Differentiates Calls, bets, and raises so you can spot which action type carries the most variance.\n\n\n\n\nCode\n# output$ev_trend &lt;- renderPlot({\n#   req(input$focus_player != \"Summary\")\n#   df &lt;- rv() %&gt;%\n#     filter(\n#       Player == input$focus_player,\n#       Action %in% c(\"bet\", \"call\", \"raise\")\n#     ) %&gt;%\n#     mutate(ev_score = coalesce(EV_call, EV_bet, EV_raise))\n#\n#   # Symmetric y-axis so gains and losses are directly comparable\n#   max_abs &lt;- max(abs(df$ev_score), na.rm = TRUE)\n#\n#   ggplot(df, aes(x = HandNumber, y = ev_score, color = Action)) +\n#     # Zero-EV baseline\n#     geom_hline(yintercept = 0, linetype = \"dashed\", color = \"grey50\") +\n#     # Each dot = one aggressive action’s EV\n#     geom_point(size = 4, alpha = 0.8) +\n#     scale_y_continuous(limits = c(-max_abs, max_abs)) +\n#     scale_x_continuous(breaks = unique(df$HandNumber)) +\n#     labs(\n#       title = paste(input$focus_player, \"EV per Action Over Hands\"),\n#       x     = \"Hand Number\",\n#       y     = \"EV (chips)\",\n#       color = \"Action Type\"\n#     ) +\n#     theme_minimal(base_size = 13)\n# })\n\n\n\n\n\nOptimal Table and Headline Summary\nThe Optimality Table ranks each player by their composite “Optimality” score and lays out the three components that feed into it, EV Edge, Bet/Raise Rate and Bluff Rate, so you can pinpoint exactly why one player sits above or below another. By presenting why one player sits above or below another. - EV Edge (= Average Equity – Avg Pot Odds) shows pure decision quality.\n\nBet/Raise Rate (= Aggressive Actions/Hands Played) measures how often a player seizes spots.\nBluff Rate (= Mean HMM Bluff Probability) captures their discipline with inpaired or weak holdings\nOptimality multiplies those three factors into one number, so a high-scoring player must excel on all fronts\n\nImmediately next to the table, the Headline Summary pulls out the story in two sentences: \nThis detailed table plus a concise, human read-able paragraph ensures that both data savvy coaches and casual observers instantly grasp who’s excelling, who is leaking chips and which levers each player should pull to improve.\n\n\n\n\n\n\nReferences\n\nBillings, D., & al., et. (2006). Algorithms and assessment in computer poker. AAAI Spring Symposium.\n\n\nBurch, P. et al. (2020). AIVAT: An action‐informed variance reduction method for poker. Transactions on Games.\n\n\nChen, B., & Ankenman, J. (2006). The mathematics of poker. ConJelCo LLC.\n\n\nKuznetsov. (2024). Hidden markov models for opponent modelling in poker. Proc. Of Another Conf.\n\n\nSire, C. (2007). Universal statistical properties of poker tournaments. Journal of Statistical Mechanics."
  }
]
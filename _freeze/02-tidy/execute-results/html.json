{
  "hash": "19a6869499d77bfd7feb755abd43400f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Chapter 2: Tidy\"\nformat: html\neditor: visual\nexecute:\n  freeze: auto\n  warning: false\n---\n\n## Tidy {#Tidy}\n\nThe tidying layer is almost entirely code-driven and lives inside 2 helpers within the file.\n\n| Helper                 | Where it fires                                   | What it does                                                                                                                                       |\n|:-----------------|:-----------------|:------------------------------------|\n| `get_action_summary()` | when a `.txt` PokerStars log is uploaded         | Regex‐parses seat headers, blind posts, bet/raise/call lines, board cards and showdowns, then explodes each hand into \"one row per player‐action.\" |\n| `recalc_analytics()`   | after tidying, every time we append or edit rows | Recalculates pot evolution, odds, equity proxies and EV so the data frame is self‐contained.                                                       |\n\n{: #tbl:helpers tbl-cap=\"Table 2.1: Overview of helper functions in the pipeline.\"}\n\n### Full Cleaning Process\n\n##### 1. File Read In\n\nBoth PokerStars text logs and CSV/Excel files are supported:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#a) Excel / CSV\n  library(readxl)\n  library(readr)\n\n  csv_data  <- read_csv(\"data/my_data.csv\")\n  xlsx_data <- read_xlsx(\"data/my_data.xlsx\")\n  \n#b) PokerStars text\n  txt_lines   <- readLines(\"data/hand_history.txt\")\n  action_tbl  <- get_action_summary(txt_lines)\n```\n:::\n\n\n##### 2. Header Nomination\n\nColumn names are canonized to avoid breaking downstream functions.\n\n##### 3. Atomic Row Construction\n\nFor text logs, our parser emits one tidy row per player-action. Each row already contains:\n\n-   **`HandNumber`**: the unique ID for each hand\\\n-   **`Player`**: the player's name\\\n-   **`Action`**: the type of action (e.g. `bet`, `call`, `raise`)\\\n-   **`BetAmount`**: how much was wagered\\\n-   **`StackBefore`**: stack size immediately before the action\\\n-   **`Street`**: the game street (`Pre-flop`,`Flop`, `Turn`,`River`)\n\n##### 4. Name Trimming\n\nClean up player names into valid R identifiers\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- list(players = \"  Vy om  \\nMax*   \\n  2Arshiya\\n Yaj ur\\n   H@rris\\nJo sh \\nMi chael  \")\n\nplayers    <- strsplit(input$players, \"\\n\")[[1]] |> trimws()\nplayer_ids <- make.names(players)\n```\n:::\n\n\n##### 5. Street Ordering\n\nEnsure each row knows its true street order, even if the CSV was shuffled:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(stringr)\n\ndata <- data.frame(\n  Street = c(\n    \"Pre-flop\",\n    \"Flop: is Ah Kd 7c\",         # Ace hearts, King diamonds, 7 clubs\n    \"River: Ah Kd 7c 3s Qh\",  # Adds river card\n    \"Flop is 9h 9s 2d\",         # Paired board\n    \"Turn: is Ah Kd 7c 3s\",      # Adds turn card\n    \"Showdown\"                  # Unmatched, will hit TRUE branch\n  )\n)\n\ndata <- data %>%\n  mutate(\n    StreetOrder = case_when(\n      Street == \"Pre-flop\"        ~ 1L,\n      str_starts(Street, \"Flop\")  ~ 2L,\n      str_starts(Street, \"Turn\")  ~ 3L,\n      str_starts(Street, \"River\") ~ 4L,\n      TRUE                        ~ 5L\n    )\n  )\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                 Street StreetOrder\n1              Pre-flop           1\n2     Flop: is Ah Kd 7c           2\n3 River: Ah Kd 7c 3s Qh           4\n4      Flop is 9h 9s 2d           2\n5  Turn: is Ah Kd 7c 3s           3\n6              Showdown           5\n```\n\n\n:::\n:::\n\n\n##### 6. Hole-Card Splitting\n\nCombine Hole1 and Hole2 into a single Hole-Card field, and rebuild the board strings:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndata <- tibble::tribble(\n  ~StreetOrder, ~Hole1, ~Hole2, ~Flop1, ~Flop2, ~Flop3, ~Turn, ~River,\n  1, \"Ah\", \"Kd\", NA,    NA,    NA,    NA,   NA,\n  2, \"Qs\", \"Qh\", \"2c\", \"7d\", \"9s\", NA,   NA,\n  3, \"Jc\", \"Tc\", \"4h\", \"5s\", \"8d\", \"As\", NA,\n  4, \"9c\", \"9d\", \"Kc\", \"Kh\", \"3s\", \"Jh\", \"Qd\",\n  5, \"2h\", \"7h\", \"5c\", \"6d\", \"Ts\", \"Ac\", \"Kd\"\n)\n\ndata <- data %>%\n  mutate(\n    HoleCards = if_else(!is.na(Hole1) & !is.na(Hole2),\n                        paste(Hole1, Hole2),\n                        NA_character_),\n\n    # Flop:\n    Flop = if_else(\n      StreetOrder >= 2 & !is.na(Flop1) & !is.na(Flop2) & !is.na(Flop3),\n      paste0(\"[\", Flop1, \" \", Flop2, \" \", Flop3, \"]\"),\n      NA_character_\n    ),\n\n    # Turn:\n    Turn = if_else(\n      StreetOrder >= 3 & !is.na(Flop1) & !is.na(Flop2) & !is.na(Flop3) & !is.na(.data$Turn),\n      paste0(\"[\", Flop1, \" \", Flop2, \" \", Flop3, \"] \", .data$Turn),\n      NA_character_\n    ),\n\n    # River:\n    River = if_else(\n      StreetOrder >= 4 & !is.na(Flop1) & !is.na(Flop2) & !is.na(Flop3) &\n        !is.na(.data$Turn) & !is.na(.data$River),\n      paste0(\"[\", Flop1, \" \", Flop2, \" \", Flop3, \" \", .data$Turn, \"] \", .data$River),\n      NA_character_\n    )\n  )\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 10\n  StreetOrder Hole1 Hole2 Flop1 Flop2 Flop3 Turn          River  HoleCards Flop \n        <dbl> <chr> <chr> <chr> <chr> <chr> <chr>         <chr>  <chr>     <chr>\n1           1 Ah    Kd    <NA>  <NA>  <NA>  <NA>          <NA>   Ah Kd     <NA> \n2           2 Qs    Qh    2c    7d    9s    <NA>          <NA>   Qs Qh     [2c …\n3           3 Jc    Tc    4h    5s    8d    [4h 5s 8d] As <NA>   Jc Tc     [4h …\n4           4 9c    9d    Kc    Kh    3s    [Kc Kh 3s] Jh [Kc K… 9c 9d     [Kc …\n5           5 2h    7h    5c    6d    Ts    [5c 6d Ts] Ac [5c 6… 2h 7h     [5c …\n```\n\n\n:::\n:::\n\n\n##### 7. Integrity & Missing‐Value Rules\n\nWe enforce two main rules to keep the data sane:\n\n1.  **Impute missing `StackAfter`**\\\n    When legacy logs omit `StackAfter`, compute it from the difference between `StackBefore` and Contribution\n\n```{=html}\n<!-- -->\n```\n2.  **Fix impossible bets**\\\n    If someone somehow \"bets\" more than their stack, we recast it as an all-in call and clamp the amount:\n\n    -   **Action**: change to `\"all-in call\"`\n    -   **BetAmount**: set to the full `StackBefore`\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}